{
	"1": {
  "prefix": "saiful",
  "body": [
    "#include<bits/stdc++.h>",
    "//#include<ext/pb_ds/assoc_container.hpp>",
    "//#include<ext/pb_ds/tree_policy.hpp>",
    "//using namespace __gnu_pbds;",
    "using namespace std;",
    "typedef long long int ll;",
    "typedef pair<int, int> pii;",
    "typedef pair<ll, ll> pll;",
    "#define nl \"\\n\"",
    "#define pb push_back",
    "#define ppb pop_back",
    "#define pf push_front",
    "#define ppf pop_front",
    "#define Yes cout<<\"YES\\n\"",
    "#define No cout<<\"NO\\n\"",
    "#define yes cout<<\"Yes\\n\"",
    "#define no cout<<\"No\\n\"",
    "#define F first",
    "#define sc second",
    "#define all(v) v.begin(), v.end()",
    "#define rall(v) v.rbegin(), v.rend()",
    "#define sortv(v) sort(v.begin(), v.end());",
    "#define rsort(v) sort(v.rbegin(), v.rend());",
    "#define revv(v) reverse(v.begin(), v.end());",
    "",
    "const int N=1e6+9;",
    "const int mod1=1e9+7, mod2=1e9+9;",
    "const int base1=137, base2=277;",
    "const long long int inf=1e9;",
    "const long double eps=1e-9;",
    "#define saiful_islam_bk",
    "",
    "void solve(){",
    "    ",
    "}",
    "int main(){",
    "  ios_base::sync_with_stdio(0);",
    "  cin.tie(0);",
    " saiful_islam_bk",
    " ll test=1;",
    "  cin>>test;",
    " for(ll ii=1; ii<=test; ii++){",
    "     //cout<<\"Case \"<<ii<<\": \";",
    "     solve();",
    " }",
    "}"
  ],
  "description": "saiful"
  },
  "2": {
  "prefix": "ifor",
  "body": [
    "for(int i=0; i<n; i++){",
    "    ",
    "}"
  ],
  "description": "2"
},
"3": {
"prefix": "jfor",
"body": [
  "for(int j=0; j<n; j++){",
  "    ",
  "}"
],
"description": "3"
},
"4": {
"prefix": "kfor",
"body": [
  "for(int k=0; k<n; k++){",
  "    ",
  "}"
],
"description": "4"
},
"5": {
"prefix": "pfor",
"body": [
  "for(int p=0; p<n; p++){",
  "    ",
  "}"
],
"description": "5"
},
"6": {
  "prefix": "arin",
  "body": [
    "ll n, m=0, k=0, ans=0; cin>>n; ll a[n];",
    "for(int i=0; i<n; i++){",
    "    cin>>a[i];",
    "}"
  ],
  "description": "6"
},
"7": {
  "prefix": "gin",
  "body": [
    "int n, m; ll u, v, w; cin>>n>>m;",
    "clr(n);",
    "for(int i=1; i<=m; i++){",
    "    cin>>u>>v;",
    "    g[u].pb(v);",
    "    g[v].pb(u);",
    "}"
  ],
  "description": "7"
},
"8": {
  "prefix": "graph",
  "body": [
    "vector<vector<ll>>g;",
    "bool vis[N];",
    "vector<ll>par, dis, col, topo, indegree;",
    "void clr(ll n){",
    "    g.clear(); par.clear(); dis.clear();",
    "    g.resize(n+1); col.assign(n+1, 0); indegree.assign(n+1, 0);",
    "    par.assign(n+1, -1); dis.assign(n+1, 0);",
    "    fill(vis, vis+n+1, false);",
    "}"
  ],
  "description": "8"
},
"9": {
  "prefix": "dfs",
  "body": [
    "void dfs(ll v){",
    "    vis[v]=true;",
    "    for(auto c:g[v]){",
    "        if(!vis[c]) dfs(c);",
    "    }",
    "}"
  ],
  "description": "9"
},
"10": {
  "prefix": "bfs",
  "body": [
    "void bfs(ll s){",
    "    queue<ll>q;",
    "    q.push(s);",
    "    vis[s]=true;",
    "    while(!q.empty()){",
    "        ll v=q.front(); q.pop();",
    "        for(auto c:g[v]){",
    "            if(!vis[c]){",
    "                q.push(c);",
    "                vis[c]=true;",
    "            }",
    "        }",
    "    }",
    "}"
  ],
  "description": "10"
},
"11": {
  "prefix": "cycle",
  "body": [
    "ll st, en;",
    "bool dfs(ll v, ll p){",
    "    col[v]=1;",
    "    for(auto u:g[v]){",
    "        if(u==p) continue; //This line only for undirected graphs",
    "        if(col[u]==0){",
    "            par[u]=v;",
    "            if(dfs(u, v)) return true;",
    "        }else if(col[u]==1){",
    "            st=u; en=v;",
    "            return true;",
    "        }",
    "    }",
    "    col[v]=2;",
    "    return false;",
    "}"
  ],
  "description": "11"
},
"12": {
  "prefix": "bipartite_graph",
  "body": [
    "bool bp=true;",
    "ll zero=0, one=0;",
    "void dfs(ll v){",
    "    vis[v]=true;",
    "    for(auto u:g[v]){",
    "        if(!vis[u]){",
    "            col[u]=1-col[v];",
    "            dfs(u);",
    "        }else if(col[u]==col[v]){",
    "            //Not Bipartite",
    "            bp=false;",
    "        }",
    "    }",
    "    zero+=col[v]==0;",
    "    one+=col[v]==0;",
    "}"
  ],
  "description": "12"
},
"13": {
  "prefix": "prims",
  "body": [
    "vector<ll>ng[N];",
    "set<pll>s;",
    "void mst(ll n){",
    "    for(int i=1; i<=n; i++){",
    "        if(par[i]!=-1){",
    "            ng[par[i]].pb(i);",
    "            ng[i].pb(par[i]);",
    "        }",
    "    }",
    "}",
    "void prims(ll source){",
    "    dis[source]=0;",
    "    s.insert({0, source});",
    "    while(!s.empty()){",
    "        auto x=*s.begin(); s.erase(x);",
    "        ll u=x.sc, w=x.F;",
    "        if(vis[u]) continue; vis[u]=true;",
    "        for(auto it:g[u]){",
    "            ll v=it.F, w=it.sc;",
    "            if(!vis[v] && dis[v]>w){",
    "                s.erase({dis[v], v});",
    "                dis[v]=w;",
    "                s.insert({dis[v], v});",
    "                par[v]=u;",
    "            }",
    "        }",
    "    }",
    "}"
  ],
  "description": "13"
},
"14": {
  "prefix": "topological_sort",
  "body": [
    "void topological_sort(ll n){",
    "    priority_queue<ll, vector<ll>, greater<ll>>zero;",
    "    for(int i=1; i<=n; i++){",
    "        if(indegree[i]==0) zero.push(i);",
    "    }",
    "    while(!zero.empty()){",
    "        ll s=zero.top(); zero.pop(); topo.pb(s);",
    "        for(auto u:g[s]){",
    "            indegree[u]--;",
    "            if(indegree[u]==0) zero.push(u);",
    "        }",
    "    }",
    "}"
  ],
  "description": "14"
},
"15": {
  "prefix": "hs",
  "body": [
    "int power(int n, int k, int mod){",
    "    int ans=1%mod; n%=mod; if(n<0) n+=mod;",
    "    while(k>0){",
    "        if(k & 1) ans=(long long)ans*n%mod;",
    "        n=(long long)n*n%mod;",
    "        k>>=1;",
    "    }",
    "    return ans;",
    "}",
    "int ip1, ip2;",
    "pii pw[N], ipw[N];",
    "void prac(){",
    "    pw[0]={1, 1};",
    "    for(int i=1; i<N; i++){",
    "        pw[i].F=1LL*pw[i-1].F*base1%mod1;",
    "        pw[i].sc=1LL*pw[i-1].sc*base2%mod2;",
    "    }",
    "    ip1=power(base1, mod1-2, mod1);",
    "    ip2=power(base2, mod2-2, mod2);",
    "    ipw[0]={1, 1};",
    "    for(int i=1; i<N; i++){",
    "        ipw[i].F=1LL*ipw[i-1].F*ip1%mod1;",
    "        ipw[i].sc=1LL*ipw[i-1].sc*ip2%mod2;",
    "    }",
    "}",
    "pii str_hash(string s){",
    "    int n=s.size();",
    "    pii hs({0, 0});",
    "    for(int i=0; i<n; i++){",
    "        hs.F+=1LL*s[i]*pw[i].F%mod1;",
    "        hs.F%=mod1;",
    "        hs.sc+=1LL*s[i]*pw[i].sc%mod2;",
    "        hs.sc%=mod2;",
    "    }",
    "    return hs;",
    "}",
    "pii pref[N];",
    "void build(string s){",
    "    int n=s.size();",
    "    for(int i=0; i<n; i++){",
    "        pref[i].F=1LL*s[i]*pw[i].F%mod1;",
    "        if(i) pref[i].F=(pref[i].F+pref[i-1].F)%mod1;",
    "        pref[i].sc=1LL*s[i]*pw[i].sc%mod2;",
    "        if(i) pref[i].sc=(pref[i].sc+pref[i-1].sc)%mod2;",
    "    }",
    "}",
    "pii get_hash(int i, int j){",
    "    pii hs({0, 0});",
    "    hs.F=pref[j].F;",
    "    if(i) hs.F=(hs.F-pref[i-1].F+mod1)%mod1;",
    "    hs.F=1LL*hs.F*ipw[i].F%mod1;",
    "    hs.sc=pref[j].sc;",
    "    if(i) hs.sc=(hs.sc-pref[i-1].sc+mod2)%mod2;",
    "    hs.sc=1LL*hs.sc*ipw[i].sc%mod2;",
    "    return hs;",
    "}"
  ],
  "description": "15"
},
"16": {
  "prefix": "lazy_segment_tree",
  "body": [
    "int a[N];",
    "#define lc (n << 1)",
    "#define rc ((n << 1) | 1)",
    "long long t[4 * N], lazy[4 * N];",
    "inline void push(int n, int b, int e){",
    "    if (lazy[n] == 0) return;",
    "    t[n] = t[n] + lazy[n] * (e - b + 1);",
    "    if (b != e){",
    "      lazy[lc] = lazy[lc] + lazy[n];",
    "      lazy[rc] = lazy[rc] + lazy[n];",
    "    }",
    "    lazy[n] = 0;",
    "}",
    "inline long long combine(long long a,long long b){",
    "    return a + b;",
    "}",
    "inline void pull(int n) {",
    "    t[n] = t[lc] + t[rc];",
    "}",
    "void build(int n, int b, int e){",
    "    lazy[n] = 0;",
    "    if (b == e){",
    "      t[n] = a[b];",
    "      return;",
    "    }",
    "    int mid = (b + e) >> 1;",
    "    build(lc, b, mid);",
    "    build(rc, mid + 1, e);",
    "    pull(n);",
    "}",
    "void upd(int n, int b, int e, int i, int j, long long v){",
    "    push(n, b, e);",
    "    if (j < b || e < i) return;",
    "    if (i <= b && e <= j) {",
    "      lazy[n] = v; //set lazy",
    "      push(n, b, e);",
    "      return;",
    "    }",
    "    int mid = (b + e) >> 1;",
    "    upd(lc, b, mid, i, j, v);",
    "    upd(rc, mid + 1, e, i, j, v);",
    "    pull(n);",
    "}",
    "long long query(int n, int b, int e, int i, int j){",
    "    push(n, b, e);",
    "    if (i > e || b > j) return 0; //return null",
    "    if (i <= b && e <= j) return t[n];",
    "    int mid = (b + e) >> 1;",
    "    return combine(query(lc, b, mid, i, j), query(rc, mid + 1, e, i, j));",
    "}"
  ],
  "description": "16"
},
"17": {
  "prefix": "segment_tree",
  "body": [
    "int a[N];",
    "#define lc (n << 1)",
    "#define rc ((n << 1) | 1)",
    "int t[4*N];",
    "static const int inf = 1e9;",
    "long long combine(long long a,long long b){",
    "    return a+b;",
    "}",
    "void pull(int n){",
    "    t[n]=t[lc]+t[rc];",
    "}",
    "void build(int n, int b, int e) {",
    "    if (b == e){",
    "      t[n] = a[b];",
    "      return;",
    "    }",
    "    int mid=(b+e)>>1;",
    "    build(lc, b, mid);",
    "    build(rc, mid + 1, e);",
    "    pull(n);",
    "}",
    "void upd(int n, int b, int e, int i, int x) {",
    "    if (b > i || e < i) return;",
    "    if (b == e && b == i) {",
    "      t[n] = x;",
    "      return;",
    "    }",
    "    int mid=(b+e)>>1;",
    "    upd(lc, b, mid, i, x);",
    "    upd(rc, mid + 1, e, i, x);",
    "    pull(n);",
    "}",
    "int query(int n, int b, int e, int i, int j) {",
    "    if (b > j || e < i) return 0;",
    "    if (b >= i && e <= j) return t[n];",
    "    int mid = (b + e) >> 1, l = n << 1, r = l | 1;",
    "    int L = query(l, b, mid, i, j);",
    "    int R = query(r, mid + 1, e, i, j);",
    "    return combine(L, R);",
    "}"
  ],
  "description": "17"
},
"18": {
  "prefix": "fori",
  "body": [
    "for(int i=n-1; i>=0; i--){",
    "    ",
    "}"
  ],
  "description": "18"
},
"19": {
  "prefix": "forj",
  "body": [
    "for(int j=n-1; j>=0; j--){",
    "    ",
    "}"
  ],
  "description": "19"
},
"20": {
  "prefix": "fork",
  "body": [
    "for(int k=n-1; k>=0; k--){",
    "    ",
    "}"
  ],
  "description": "20"
},
"21": {
  "prefix": "forp",
  "body": [
    "for(int p=n-1; p>=0; p--){",
    "    ",
    "}"
  ],
  "description": "21"
},
"22": {
  "prefix": "divisor",
  "body": [
    "vector<int>d[N];",
    "void ok(){",
    "  for(int i=1; i*i<N; i++){",
    "      for(int j=i*i; j<N; j+=i){",
    "        d[j].pb(i);",
    "        if(j/i!=i) d[j].pb(j/i);",
    "      }",
    "  }",
    "}"
  ],
  "description": "22"
},
"23": {
  "prefix": "trie",
  "body": [
    "class vertex{",
    "public:",
    " char alphabet;",
    " vector<vertex*>child;",
    " bool exist;",
    " int cnt;",
    " vertex(char a):alphabet(a), exist(false){child.assign(26, NULL), cnt=0;}",
    "};",
    "class Trie{",
    "private:",
    " vertex* root;",
    "public:",
    " Trie(){ root=new vertex('!');}",
    " void insert(string word){",
    "     vertex* cur=root;",
    "     for(int i=0; i<word.size(); i++){",
    "     int id=word[i]-'a';",
    "     if(cur->child[id]==NULL) cur->child[id]=new vertex(word[i]);",
    "         cur=cur->child[id];",
    "         cur->cnt++;",
    "     }",
    "     cur->exist=true;",
    " }",
    " void deleteString(vertex* cur, const string& word, int depth=0){",
    "     if(depth==word.size()){",
    "         if(cur->exist){",
    "             cur->exist=false;",
    "             cur->cnt--;",
    "         }",
    "         return;",
    "     }",
    "     int id=word[depth]-'a';",
    "     if(cur->child[id]!=NULL){",
    "         deleteString(cur->child[id], word, depth + 1);",
    "         cur->cnt--;",
    "         if(cur->child[id]->cnt==0){",
    "             delete cur->child[id];",
    "             cur->child[id]=NULL;",
    "         }",
    "     }",
    " }",
    " void del(string word){",
    "     deleteString(root, word);",
    " }",
    " bool search(string word){",
    "     vertex* cur=root;",
    "     for(int i=0; i<word.size(); i++){",
    "         int id=word[i]-'a';",
    "         if(cur->child[id]==NULL) return false;",
    "         cur=cur->child[id];",
    "     }",
    "     return cur->exist;",
    " }",
    " int countPrefix(string prefix){",
    "     vertex* cur=root;",
    "     for(int i=0; i<prefix.size(); i++){",
    "         int id=prefix[i]-'a';",
    "         if(cur->child[id]==NULL) return 0;",
    "         cur=cur->child[id];",
    "     }",
    "     return cur->cnt;",
    " }",
    " string lcp(){ // longest common prefix",
    "     string prefix=\"\";",
    "     vertex* cur=root;",
    "     while(true){",
    "         int numChildren=0, id=-1;",
    "         for(int i=0; i<26; ++i){",
    "             if(cur->child[i]!=NULL){",
    "                 numChildren++;",
    "                 id=i;",
    "             }",
    "         }",
    "         if(numChildren!=1 || cur->exist) break;",
    "         cur=cur->child[id];",
    "         prefix+=cur->alphabet;",
    "     }",
    "     return prefix;",
    " }",
    "",
    "};"
  ],
  "description": "23"
},
"24": {
  "prefix": "sieve",
  "body": [
    "vector<int> primes; bool is_prime[N];",
    "void sieve(){",
    "    for(int i=2; i<N; i++) is_prime[i]=true;",
    "    for(int i=2; i*i<N; i++){",
    "        if(is_prime[i]){",
    "            for(int j=i*i; j<N; j+=i) is_prime[j]=false;",
    "        }",
    "    }",
    "    for(int i=2; i<N; i++){",
    "        if(is_prime[i]) primes.push_back(i);",
    "    }",
    "}"
  ],
  "description": "24"
},
"25": {
  "prefix": "divisor_sieve",
  "body": [
    "vector<int>d[N];",
    "void ok(){",
    "  for(int i=1; i*i<N; i++){",
    "      for(int j=i*i; j<N; j+=i){",
    "        d[j].push_back(i);",
    "        if(j/i!=i) d[j].push_back(j/i);",
    "      }",
    "  }",
    "}"
  ],
  "description": "25"
},
"26": {
  "prefix": "extended_euclidian",
  "body": [
    "pii extendedEuclid(int a, int b){",
    "    if(b==0) return pii(1, 0);",
    "    pii d= extendedEuclid(b, a%b);",
    "    return pii(d.sc, d.F-d.sc*(a / b));",
    "}"
  ],
  "description": "26"
},
"27": {
  "prefix": "tentombase",
  "body": [
    "char a[16]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};",
    "string tenTombase(int n, int m){",
    "    int temp=n; string result=\"\";",
    "    while (temp!=0){",
    "        result=a[temp%m]+result; temp/=m;",
    "    }",
    "    return result;",
    "}"
  ],
  "description": "27"
},
"28": {
  "prefix": "mtoten",
  "body": [
    "string num=\"0123456789ABCDE\";",
    "int mToTen(string n, int m){",
    "    int multi=1, result=0;",
    "    for(int i=n.size()-1; i>=0; i--){",
    "        result+=num.find(n[i])*multi;",
    "        multi*=m;",
    "    }",
    "}"
  ],
  "description": "28"
},
"29": {
  "prefix": "longest_palindromic_substring",
  "body": [
    "string longestPalindrome(string s){",
    "    string t=\"@#\";",
    "    for(char c:s) t+=c, t+='#'; t+='$';",
    "    int n=t.size(), id=0, j=0, maxLen=0, maxid=0;",
    "    vector<int>p(n, 0);",
    "    for(int i=1; i<n-1; i++){",
    "        if(i<j) p[i]=min(j-i, p[2*id-i]);",
    "        while(t[i+p[i]+1]==t[i-p[i]-1]) p[i]++;",
    "        if(i+p[i]>j) id=i, j=i+p[i];",
    "        if(p[i]>maxLen) maxLen=p[i], maxid=i;",
    "    }",
    "    int start=(maxid-maxLen)/2;",
    "    return s.substr(start, maxLen);",
    "}"
  ],
  "description": "29"
},
"30": {
  "prefix": "dijkstra",
  "body": [
    "vector<pii>g[N]; vector<int>dis(N, INT_MAX);",
    "void dijkstra(int s){",
    "    priority_queue<pii, vector<pii>, greater<pii>>pq;",
    "    pq.push({0, s}); dis[s]=0;",
    "    while(!pq.empty()){",
    "        int d=pq.top().F, u=pq.top().sc; pq.pop();",
    "        if(d>dis[u]) continue;",
    "        for(auto p:g[u]){",
    "            int v=p.F, w=p.sc;",
    "            if(dis[u]+w<dis[v]){",
    "                dis[v]=dis[u]+w; pq.push({dis[v], v});",
    "            }",
    "        }",
    "    }",
    "}"
  ],
  "description": "30"
},
"31": {
  "prefix": "bellman_ford",
  "body": [
    "vector<int>dist(N, INT_MAX);",
    "void bellman(int s){",
    "    dist[s]=0; queue<int>q; q.push(s);",
    "    vector<int>in_queue(N, 0); in_queue[s]=1;",
    "    while(!q.empty()){",
    "        int u=q.front(); q.pop(); in_queue[u]=0;",
    "        for(auto p:g[u]){",
    "            auto v=p.first, w=p.second;",
    "            if(dist[u]+w>=dist[v]) continue;",
    "            dist[v]=dist[u]+w;",
    "            if(in_queue[v]) continue;",
    "            q.push(v); in_queue[v]=1;",
    "        }",
    "    }",
    "}"
  ],
  "description": "31"
},
"32": {
  "prefix": "articulation_point_bridge",
  "body": [
    "int t=0;",
    "vector<pii>bridge; vector<bool>ap(N, false);",
    "vector<int>in(N, -1), low(N), par(N, -1);",
    "void dfs(int u, int p){",
    "    in[u]=low[u]=++t; int cnt=0;",
    "    for(int v:g[u]){",
    "        if(v==p) continue;",
    "        if(in[v]==-1){",
    "            par[v]=u; cnt++; dfs(v, u);",
    "            low[u]=min(low[u], low[v]);",
    "            if(par[u]==-1 && cnt>1) ap[u]=true;",
    "            if(par[u]!=-1 && low[v]>=in[u]) ap[u]=true;",
    "            if(low[v]>in[u]) bridge.push_back({u, v});",
    "        }else low[u]=min(low[u], in[v]);",
    "    }",
    "}"
  ],
  "description": "32"
},
"33": {
  "prefix": "scc",
  "body": [
    "vector<vector<ll>> g(N), gt(N), scc;",
    "bool vis[N]; stack<int> st; vector<ll> component;",
    "void dfs1(int v){",
    "    vis[v]=true;",
    "    for(int u:g[v]) if(!vis[u]) dfs1(u);",
    "    st.push(v);",
    "}",
    "void dfs2(int v){",
    "    vis[v]=true; component.pb(v);",
    "    for(int u:gt[v]) if(!vis[u]) dfs2(u);",
    "}",
    "void ok(int n){",
    "     for(int i=1; i<=n; i++) if(!vis[i]) dfs1(i); ",
    "    fill(vis, vis+N, false);",
    "    while(!st.empty()){",
    "        int v=st.top(); st.pop(); component.clear();",
    "        if(!vis[v]){",
    "            dfs2(v), scc.pb(component);",
    "        }",
    "    }",
    "}",
    "//in edge input: g[u].pb(v); gt[v].pb(u);"
  ],
  "description": "33"
},
"34": {
  "prefix": "lca",
  "body": [
    "const int N=1e5+9, LOG=17;",
    "int up[N][LOG], depth[N];",
    "vector<int>g[N];",
    "/*write this in main function before call dfs: 	memset(up, -1, sizeof(up));*/ ",
    "void dfs(int u, int p=-1){",
    "    up[u][0]=p;",
    "    for(int i=1; i<LOG; i++)",
    "        if(up[u][i-1]!=-1) up[u][i]=up[up[u][i-1]][i-1];",
    "    for(int v:g[u]){",
    "        if(v!=p){ depth[v]=depth[u]+1; dfs(v, u); }",
    "    }",
    "}",
    "int lca(int u, int v){",
    "    if(depth[u]<depth[v]) swap(u, v);",
    "    for(int i=LOG-1; i>=0; i--){",
    "        if((depth[u]-(1<<i))>=depth[v]) u=up[u][i]; }",
    "    if(u==v) return u;",
    "    for(int i=LOG-1; i>=0; i--){",
    "        if(up[u][i]!=up[v][i]){ u=up[u][i]; v=up[v][i]; }",
    "    }",
    "    return up[u][0];",
    "}",
    "",
    "//Distance Between Two Nodes:",
    "int distance(int u, int v){",
    "    int lca_uv=lca(u, v);",
    "    return depth[u]+depth[v]-2*depth[lca_uv];",
    "}",
    "//Find the k-th ancestor of a node:",
    "int kth_ancestor(int u, int k){",
    "    for(int i=LOG-1; i>=0; i--){",
    "        if(k>=(1<<i)){ u=up[u][i]; k-=(1<<i); }",
    "    }",
    "    return u;",
    "}"
  ],
  "description": "34"
},
"35": {
  "prefix": "2dfs",
  "body": [
    "const int dx[4]={-1, 1, 0, 0};",
    "const int dy[4]={0, 0, -1, 1};",
    "int n, m; int vis[N][N];",
    "void dfs(int x, int y) {",
    "    if(x<0 || x>=n || y<0 || y>=m) return;",
    "    vis[x][y]=true;",
    "    for(int i=0; i<4; i++){",
    "        int a=x+dx[i], b=y+dy[i];",
    "        if(!vis[a][b]) dfs(a, b);",
    "    }",
    "}"
  ],
  "description": "35"
},
"36": {
  "prefix": "2bfs",
  "body": [
    "const int dx[4]={-1, 1, 0, 0};",
    "const int dy[4]={0, 0, -1, 1};",
    "int n, m; int vis[N][N];",
    "void bfs(int x, int y){",
    "    queue<pair<int, int>>q;",
    "    q.push({x, y});",
    "    vis[x][y]=true;",
    "    while(!q.empty()){",
    "        int x=q.front().F, y=q.front().sc; q.pop();",
    "        for(int i=0; i<4; i++){",
    "            int a=x+dx[i], b=y+dy[i];",
    "            if(a>=0 && a<n && b>=0 && b<m && !vis[a][b]){",
    "                vis[a][b]=true; q.push({a, b});",
    "            }",
    "        }",
    "    }",
    "}"
  ],
  "description": "36"
},
"37": {
  "prefix": "string_multiply",
  "body": [
    "string multiply(string a, string b){",
    "    if(a==\"0\" or b==\"0\") return \"0\";",
    "    int n=a.size(), m=b.size();",
    "    vector<int>nm(n+m,0);",
    "    for(int i=n-1; i>=0; i--){",
    "        for(int j=m-1; j>=0; j--){",
    "            nm[i+j+1]+=(a[i]-'0')*(b[j]-'0');",
    "            nm[i+j]+=nm[i+j+1]/10;",
    "            nm[i+j+1]=nm[i+j+1]%10;",
    "        }",
    "    }",
    "    int i=0; string s=\"\";",
    "    while(i<nm.size() && nm[i]==0) i++;",
    "    while(i<nm.size()){",
    "        s.push_back(nm[i]+'0'); i++;",
    "    }",
    "    return s;",
    "}"
  ],
  "description": "37"
},
"38": {
  "prefix": "kmp",
  "body": [
    "void kmp(string s, string t){",
    "    vector<int>lps(t.size(), 0);",
    "    for(int i=1, len=0; i<t.size();){",
    "        if(t[i]==t[len]) lps[i++]=++len;",
    "        else if(len) len=lps[len-1];",
    "        else lps[i++]=0;",
    "    }",
    "    for(int i=0, j=0; i<s.size();){",
    "        if(s[i]==t[j]) i++, j++; ",
    "        if(j==t.size()) cout<<\"Found \"<<i-j<<\"\\n\", j=lps[j-1];",
    "        else if(i<s.size() && s[i]!=t[j]) j?j=lps[j-1]:i++; ",
    "    }",
    "}"
  ],
  "description": "38"
},
"39": {
  "prefix": "zalgo",
  "body": [
    "vector<int> zalgo(string s){",
    "    int n=s.size(), l=0, r=0;",
    "    vector<int>z(n, 0);",
    "    for(int i=1; i<n; ++i){",
    "        if(i<=r) z[i]=min(r-i+1, z[i-l]);",
    "        while(i+z[i]<n && s[z[i]]==s[i+z[i]]) z[i]++;",
    "        if(i+z[i]-1>r) l=i, r=i+z[i]-1;",
    "    }",
    "    return z;",
    "}",
    "//Longest prefix-suffix:",
    "int findLongestPrefixSuffix(string s){",
    "    vector<int>z=zalgo(s); int n=s.size(), ans=0;",
    "    for(int i=1; i<n; i++){ if(z[i]==n-i) ans=z[i]; }",
    "    return ans;",
    "}",
    "//Count Unique Substring:",
    "//Z-function এর অ্যারের সবগুলো ভ্যালুর যোগফলই ইউনিক সাবস্ট্রিং এর সংখ্যা।",
    "//Ans+=z[i];  যেখানে, (0<=i<n)"
  ],
  "description": "39"
},
"40": {
  "prefix": "npr",
  "body": [
    "int npr(int n, int r){",
    "    if(n<r) return 0;",
    "    return (fa[n]*invfa[n-r])%M;",
    "}"
  ],
  "description": "40"
},
"41": {
  "prefix": "ncr",
  "body": [
    "int ncr(int n, int r){",
    "    if(n<r) return 0;",
    "    return (fa[n]*invfa[r]%M)*invfa[n-r]%M;",
    "}"
  ],
  "description": "41"
},
"42": {
  "prefix": "factorial%mod",
  "body": [
    "int fa[N], invfa[N];",
    "void factorial(){",
    "    fa[0]=1;",
    "    for(int i=1; i<N; i++){",
    "        fa[i]=(fa[i-1]*i)%mod1;",
    "    }",
    "    invfa[N-1]=power(fa[N-1], mod1-2, mod1);",
    "    for(int i=N-2; i>=0; i--){",
    "        invfa[i]=(invfa[i+1]*(i+1))%mod1;",
    "    }",
    "}"
  ],
  "description": "42"
},
"43": {
  "prefix": "lexicographycally_smallest_cycle_shift",
  "body": [
    "int lcp(int i, int j, int x, int y){",
    "    int l=1, r=min(j-i+1, y-x+1), ans=0;",
    "    while(l<=r){",
    "        int mid=l+r>>1;",
    "        if(get_hash(i, i+mid-1)==get_hash(x, x+mid-1)) ans=mid, l=mid+1;",
    "        else r=mid-1;",
    "    }",
    "    return ans;",
    "}",
    "string s;",
    "int cmp(int i, int j, int x, int y){",
    "    int lc=lcp(i, j, x, y), len1=j-i+1, len2=y-x+1;",
    "    if(len1==len2 && lc==len1) return 0;",
    "    else if(lc==len1) return -1;",
    "    else if(lc==len2) return 1;",
    "    else return (s[i+lc]<s[x+lc]?-1:1);",
    "}",
    "string lsc(){//lexicographically smallest cyclic shift ",
    "    s+=s; build(s);",
    "    int n=s.size()/2, mni=0, mnj=n-1;",
    "    for(int i=1; i<n; i++){",
    "        int x=cmp(mni, mnj, i, i+n-1);",
    "        if(x==1) mni=i, mnj=i+n-1;",
    "    }",
    "    return s.substr(mni, n);",
    "}"
  ],
  "description": "43"
},
"44": {
  "prefix": "prime_factorization",
  "body": [
    "//Prime Factor-1:",
    "vector<int>factor[N];",
    "void primeFactors(){",
    "    for(int i=2; i<=N; i++){",
    "        Int n=i;",
    "        while(n%2==0){",
    "            factor[i].pb(2); n=n/2;",
    "        }",
    "        for(int j=3; j*j<=n; j+=2){",
    "            while(n%j==0){",
    "                factor[i].pb(j); n=n/j;",
    "            }",
    "        }",
    "        if(n>2) factor[i].pb(n);",
    "    }",
    "}",
    "//Prime Factorization-2:",
    "vector<pair<int, int>>f;",
    "void prime_factorization(long long num){",
    "    for(long long i=2; i*i<=num; i++){",
    "        if(num%i==0){",
    "            long long ctr = 0;",
    "            while(num%i==0){",
    "                ctr++; num/=i;",
    "            }",
    "            f.push_back(make_pair(i, ctr));",
    "        }",
    "    }",
    "    if(num!=1) f.push_back(make_pair(num, 1));",
    "    //prime_factorization(m);",
    "}"
  ],
  "description": "44"
},
"45": {
  "prefix": "",
  "body": [
    "ll ori(point a, point b, point c){",
    "    ll val=(c.x-b.x)*(b.y-a.y)-(b.x-a.x)*(c.y-b.y);",
    "    return val?val/abs(val):0;",
    "}",
    "vector<point> convex_hull(vector<point>&p){",
    "    ll m, k=1, n=p.size(); if(n<=1) return p;",
    "    sort(p.begin(), p.end()); vector<point>hull;",
    "    for(ll i=0; i<n; i++){",
    "        m=hull.size();",
    "        while(m>k && ori(hull[m-2], hull[m-1], p[i])<0){",
    "            hull.pop_back();",
    "            m=hull.size();",
    "        }",
    "        hull.push_back(p[i]);",
    "    }",
    "    k=hull.size();",
    "    for(ll i=n-2; i>=0; i--){",
    "        m=hull.size();",
    "        while(m>k && ori(hull[m-2], hull[m-1], p[i])<0){",
    "            hull.pop_back();",
    "            m=hull.size();",
    "        }",
    "        hull.push_back(p[i]);",
    "    }",
    "    hull.pop_back();",
    "    return hull;",
    "}"
  ],
  "description": "45"
}
}
