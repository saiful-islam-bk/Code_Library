{
	"1": {
  "prefix": "saiful",
  "body": [
    "#include<bits/stdc++.h>",
    "//#include<ext/pb_ds/assoc_container.hpp>",
    "//#include<ext/pb_ds/tree_policy.hpp>",
    "//using namespace __gnu_pbds;",
    "using namespace std;",
    "typedef long long int ll;",
    "typedef vector<int> vi;",
    "typedef vector<ll>vll;",
    "typedef pair<int, int> pii;",
    "typedef pair<ll, ll> pll;",
    "typedef list<int> li;",
    "typedef set<int> sti;",
    "typedef map<int, int> mii;",
    "typedef map<ll, ll> mll;",
    "typedef unordered_map<int, int> umii;",
    "typedef unordered_map<ll, ll> umll;",
    "typedef unordered_set<ll> us;",
    "typedef priority_queue<ll> pq;",
    "typedef deque<ll> dq;",
    "#define nl \"\\n\"",
    "#define pb push_back",
    "#define ppb pop_back",
    "#define pf push_front",
    "#define ppf pop_front",
    "#define Yes cout<<\"YES\\n\";",
    "#define No cout<<\"NO\\n\";",
    "#define yes cout<<\"Yes\\n\";",
    "#define no cout<<\"No\\n\";",
    "#define F first",
    "#define sc second",
    "#define all(v) v.begin(), v.end()",
    "#define sortv(v) sort(v.begin(), v.end());",
    "#define rsort(v) sort(v.rbegin(), v.rend());",
    "#define revv(v) reverse(v.begin(), v.end());",
    "",
    "const int N=1e6+9;",
    "const int mod1=1e9+7, mod2=1e9+9;",
    "const int base1=29, base2=67;",
    "const long long int inf=1e18;",
    "#define saiful_islam_bk",
    "",
    "void solve(){",
    "    ",
    "}",
    "int main(){",
    "  ios_base::sync_with_stdio(0);",
    "  cin.tie(0);",
    "	saiful_islam_bk",
    "	ll test=1;",
    "	 cin>>test;",
    "	for(ll ii=1; ii<=test; ii++){",
    "	    //cout<<\"Case \"<<ii<<\": \";",
    "	    solve();",
    "	}",
    "}"
  ],
  "description": "saiful"
  },
  "2": {
  "prefix": "ifor",
  "body": [
    "for(ll i=0; i<n; i++){",
    "    ",
    "}"
  ],
  "description": "2"
},
"3": {
"prefix": "jfor",
"body": [
  "for(ll j=0; j<n; j++){",
  "    ",
  "}"
],
"description": "3"
},
"4": {
"prefix": "kfor",
"body": [
  "for(ll k=0; k<n; k++){",
  "    ",
  "}"
],
"description": "4"
},
"5": {
"prefix": "pfor",
"body": [
  "for(ll p=0; p<n; p++){",
  "    ",
  "}"
],
"description": "5"
},
"6": {
  "prefix": "arin",
  "body": [
    "ll n, m=0, k=0, ans=0; cin>>n; ll a[n];",
    "for(ll i=0; i<n; i++){",
    "    cin>>a[i];",
    "}"
  ],
  "description": "6"
},
"7": {
  "prefix": "gin",
  "body": [
    "ll n, m, u, v, w; cin>>n>>m;",
    "clr(n);",
    "for(ll i=1; i<=m; i++){",
    "    cin>>u>>v;",
    "    g[u].pb(v);",
    "    g[v].pb(u);",
    "}"
  ],
  "description": "7"
},
"8": {
  "prefix": "graph",
  "body": [
    "vector<vector<ll>>g;",
    "bool vis[N];",
    "vector<ll>par, dis, col, topo, indegree;",
    "void clr(ll n){",
    "    g.clear(); par.clear(); dis.clear();",
    "    g.resize(n+1); col.assign(n+1, 0); indegree.assign(n+1, 0);",
    "    par.assign(n+1, -1); dis.assign(n+1, 0);",
    "    fill(vis, vis+n+1, false);",
    "}"
  ],
  "description": "8"
},
"9": {
  "prefix": "dfs",
  "body": [
    "void dfs(ll v){",
    "    vis[v]=true;",
    "    for(auto c:g[v]){",
    "        if(!vis[c]) dfs(c);",
    "    }",
    "}"
  ],
  "description": "9"
},
"10": {
  "prefix": "bfs",
  "body": [
    "void bfs(ll s){",
    "    queue<ll>q;",
    "    q.push(s);",
    "    vis[s]=true;",
    "    while(!q.empty()){",
    "        ll v=q.front(); q.pop();",
    "        for(auto c:g[v]){",
    "            if(!vis[c]){",
    "                q.push(c);",
    "                vis[c]=true;",
    "            }",
    "        }",
    "    }",
    "}"
  ],
  "description": "10"
},
"11": {
  "prefix": "cycle",
  "body": [
    "ll st, en;",
    "bool dfs(ll v, ll p){",
    "    col[v]=1;",
    "    for(auto u:g[v]){",
    "        if(u==p) continue; //This line only for undirected graphs",
    "        if(col[u]==0){",
    "            par[u]=v;",
    "            if(dfs(u, v)) return true;",
    "        }else if(col[u]==1){",
    "            st=u; en=v;",
    "            return true;",
    "        }",
    "    }",
    "    col[v]=2;",
    "    return false;",
    "}"
  ],
  "description": "11"
},
"12": {
  "prefix": "bipartite_graph",
  "body": [
    "bool bp=true;",
    "ll zero=0, one=0;",
    "void dfs(ll v){",
    "    vis[v]=true;",
    "    for(auto u:g[v]){",
    "        if(!vis[u]){",
    "            col[u]=1-col[v];",
    "            dfs(u);",
    "        }else if(col[u]==col[v]){",
    "            //Not Bipartite",
    "            bp=false;",
    "        }",
    "    }",
    "    zero+=col[v]==0;",
    "    one+=col[v]==0;",
    "}"
  ],
  "description": "12"
},
"13": {
  "prefix": "prims",
  "body": [
    "vector<ll>ng[N];",
    "set<pll>s;",
    "void mst(ll n){",
    "    for(ll i=1; i<=n; i++){",
    "        if(par[i]!=-1){",
    "            ng[par[i]].pb(i);",
    "            ng[i].pb(par[i]);",
    "        }",
    "    }",
    "}",
    "void prims(ll source){",
    "    dis[source]=0;",
    "    s.insert({0, source});",
    "    while(!s.empty()){",
    "        auto x=*s.begin(); s.erase(x);",
    "        ll u=x.sc, w=x.F;",
    "        if(vis[u]) continue; vis[u]=true;",
    "        for(auto it:g[u]){",
    "            ll v=it.F, w=it.sc;",
    "            if(!vis[v] && dis[v]>w){",
    "                s.erase({dis[v], v});",
    "                dis[v]=w;",
    "                s.insert({dis[v], v});",
    "                par[v]=u;",
    "            }",
    "        }",
    "    }",
    "}"
  ],
  "description": "13"
},
"14": {
  "prefix": "topological_sort",
  "body": [
    "void topological_sort(ll n){",
    "    priority_queue<ll, vector<ll>, greater<ll>>zero;",
    "    for(ll i=1; i<=n; i++){",
    "        if(indegree[i]==0) zero.push(i);",
    "    }",
    "    while(!zero.empty()){",
    "        ll s=zero.top(); zero.pop(); topo.pb(s);",
    "        for(auto u:g[s]){",
    "            indegree[u]--;",
    "            if(indegree[u]==0) zero.push(u);",
    "        }",
    "    }",
    "}"
  ],
  "description": "14"
},
"15": {
  "prefix": "hs",
  "body": [
    "int power(int n, int k, int mod){",
    "    int ans=1%mod; n%=mod; if(n<0) n+=mod;",
    "    while(k>0){",
    "        if(k & 1) ans=(long long)ans*n%mod;",
    "        n=(long long)n*n%mod;",
    "        k>>=1;",
    "    }",
    "    return ans;",
    "}",
    "int ip1, ip2;",
    "pii pw[N], ipw[N];",
    "void prac(){",
    "    pw[0]={1, 1};",
    "    for(int i=1; i<N; i++){",
    "        pw[i].F=1LL*pw[i-1].F*base1%mod1;",
    "        pw[i].sc=1LL*pw[i-1].sc*base2%mod2;",
    "    }",
    "    ip1=power(base1, mod1-2, mod1);",
    "    ip2=power(base2, mod2-2, mod2);",
    "    ipw[0]={1, 1};",
    "    for(int i=1; i<N; i++){",
    "        ipw[i].F=1LL*ipw[i-1].F*ip1%mod1;",
    "        ipw[i].sc=1LL*ipw[i-1].sc*ip2%mod2;",
    "    }",
    "}",
    "pii str_hash(string s){",
    "    int n=s.size();",
    "    pii hs({0, 0});",
    "    for(int i=0; i<n; i++){",
    "        hs.F+=1LL*s[i]*pw[i].F%mod1;",
    "        hs.F%=mod1;",
    "        hs.sc+=1LL*s[i]*pw[i].sc%mod2;",
    "        hs.sc%=mod2;",
    "    }",
    "    return hs;",
    "}",
    "pii pref[N];",
    "void build(string s){",
    "    int n=s.size();",
    "    for(int i=0; i<n; i++){",
    "        pref[i].F=1LL*s[i]*pw[i].F%mod1;",
    "        if(i) pref[i].F=(pref[i].F+pref[i-1].F)%mod1;",
    "        pref[i].sc=1LL*s[i]*pw[i].sc%mod2;",
    "        if(i) pref[i].sc=(pref[i].sc+pref[i-1].sc)%mod2;",
    "    }",
    "}",
    "pii get_hash(int i, int j){",
    "    pii hs({0, 0});",
    "    hs.F=pref[j].F;",
    "    if(i) hs.F=(hs.F-pref[i-1].F+mod1)%mod1;",
    "    hs.F=1LL*hs.F*ipw[i].F%mod1;",
    "    hs.sc=pref[j].sc;",
    "    if(i) hs.sc=(hs.sc-pref[i-1].sc+mod2)%mod2;",
    "    hs.sc=1LL*hs.sc*ipw[i].sc%mod2;",
    "    return hs;",
    "}"
  ],
  "description": "15"
},
"16": {
  "prefix": "lazy_segment_tree",
  "body": [
    "int a[N];",
    "#define lc (n << 1)",
    "#define rc ((n << 1) | 1)",
    "long long t[4 * N], lazy[4 * N];",
    "inline void push(int n, int b, int e){",
    "    if (lazy[n] == 0) return;",
    "    t[n] = t[n] + lazy[n] * (e - b + 1);",
    "    if (b != e){",
    "      lazy[lc] = lazy[lc] + lazy[n];",
    "      lazy[rc] = lazy[rc] + lazy[n];",
    "    }",
    "    lazy[n] = 0;",
    "}",
    "inline long long combine(long long a,long long b){",
    "    return a + b;",
    "}",
    "inline void pull(int n) {",
    "    t[n] = t[lc] + t[rc];",
    "}",
    "void build(int n, int b, int e){",
    "    lazy[n] = 0;",
    "    if (b == e){",
    "      t[n] = a[b];",
    "      return;",
    "    }",
    "    int mid = (b + e) >> 1;",
    "    build(lc, b, mid);",
    "    build(rc, mid + 1, e);",
    "    pull(n);",
    "}",
    "void upd(int n, int b, int e, int i, int j, long long v){",
    "    push(n, b, e);",
    "    if (j < b || e < i) return;",
    "    if (i <= b && e <= j) {",
    "      lazy[n] = v; //set lazy",
    "      push(n, b, e);",
    "      return;",
    "    }",
    "    int mid = (b + e) >> 1;",
    "    upd(lc, b, mid, i, j, v);",
    "    upd(rc, mid + 1, e, i, j, v);",
    "    pull(n);",
    "}",
    "long long query(int n, int b, int e, int i, int j){",
    "    push(n, b, e);",
    "    if (i > e || b > j) return 0; //return null",
    "    if (i <= b && e <= j) return t[n];",
    "    int mid = (b + e) >> 1;",
    "    return combine(query(lc, b, mid, i, j), query(rc, mid + 1, e, i, j));",
    "}"
  ],
  "description": "16"
},
"17": {
  "prefix": "segment_tree",
  "body": [
    "int a[N];",
    "int t[4 * N];",
    "static const int inf = 1e9;",
    "void build(int n, int b, int e) {",
    "    if (b == e) {",
    "      t[n] = a[b];",
    "      return;",
    "    }",
    "    int mid = (b + e) >> 1, l = n << 1, r = l | 1;",
    "    build(l, b, mid);",
    "    build(r, mid + 1, e);",
    "    t[n] = max(t[l], t[r]);",
    "}",
    "void upd(int n, int b, int e, int i, int x) {",
    "    if (b > i || e < i) return;",
    "    if (b == e && b == i) {",
    "      t[n] = x;",
    "      return;",
    "    }",
    "    int mid = (b + e) >> 1, l = n << 1, r = l | 1;",
    "    upd(l, b, mid, i, x);",
    "    upd(r, mid + 1, e, i, x);",
    "    t[n] = max(t[l], t[r]);",
    "}",
    "int query(int n, int b, int e, int i, int j) {",
    "    if (b > j || e < i) return -inf;",
    "    if (b >= i && e <= j) return t[n];",
    "    int mid = (b + e) >> 1, l = n << 1, r = l | 1;",
    "    int L = query(l, b, mid, i, j);",
    "    int R = query(r, mid + 1, e, i, j);",
    "    return max(L, R);",
    "}"
  ],
  "description": "17"
}
}
